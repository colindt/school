<html autopagermatchedrules="1"><head>

<title>
Boggle
</title>

<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="content-script-type" content="text/javascript">
<meta http-equiv="content-style-type" content="text/css">

<link rel="stylesheet" type="text/css" media="screen,projection" href="lab3-boggle.php_files/style.css">

</head>
<body>

<div class="box">
<h1>
Computer Science 235 :: Data Structures and Algorithms
</h1>
</div>

<div class="main">

<div class="center">
<h2>
Boggle
</h2>
</div>
<hr>

<p>
Note: Projects are to be completed by each student individually
(not by groups of students).
</p>


<p>
The objective of this project is to design and implement
the data structures and algorithms necessary for
a computer player to play the popular board game Boggle.
</p>



<h3>
What is Boggle?
</h3>

<p>
The game of Boggle is played with a set of sixteen letter cubes,
which are standard six-sided dice
except that they are marked with letters of
the alphabet instead of numbers.
The cubes are rolled and arranged into
a 4x4 square that might look like this:
</p>

<p>
<img src="lab3-boggle.php_files/image002.gif" height="193" width="193">
</p>

<p>
The object of the game is to start at one cube
and then work through a chain of letters to form
a word that meets the following conditions:
</p>

<ul>

<li>
The word must be at least four letters long.

</li><li>
The path traced out by the letters in the word must be
connected horizontally, vertically, or diagonally.
You can't skip over intervening cubes to get the next letter.

</li><li>
Each cube may be used only once in a given word.

</li></ul>

<p>
For example, the sample board contains the word
<b>PEACE</b>
as follows:
</p>

<p>
<img src="lab3-boggle.php_files/image004.gif" height="193" width="193">
</p>

<p>
The board, however, does not contain the word
<b>PLACE</b>
which would require jumping from the
<b>P</b>
to the
<b>L</b>
and then back to the
<b>A</b>
.

Similarly, it is not possible to make the word
<b>POPE</b>
,
because doing so would require reusing the
<b>P</b>
.
</p>


<p>
The Boggle player you create will find and output
all the valid words on a given board.
Valid words are those listed in a given dictionary.
</p>



<h3>
Example
</h3>

<p>
When the Boggle player is run with the
following dictionary and board
it gives the output shown below.
</p>


<h4>
Dictionary
</h4>

<pre>blue
boot
booth
cat
dog
orbit
riot
robot
root
run
</pre>


<h4>
Board
</h4>

<pre>R B O
O I T
R O H
</pre>


<h4>
Output
</h4>

<pre>boot
booth
orbit
riot
robot
root
</pre>



<h3>
Dictionary File Format
</h3>

<p>
The dictionary is a text file that contains
a list of words, one word per line.
When comparing words on the board
with words in the dictionary,
use a comparison that is not case-sensitve.
</p>


 
<h3>
Boggle Board Files
</h3>

<p>
The Boggle board is a text file that contains
a list of strings separated by white space.
Each string gives the letter(s) for one of the
tiles on the Boggle board.
</p>

<p>
The number of strings in the file will always be
a perfect square such as 9, 16, or 25.
(The board will always be square.)
In standard Boggle the number of tiles is 16
(a 4x4 board).
Your Boggle player needs to work correctly
with a square board of any size.
</p>

<p>
The strings in the file are organized by row.
The strings for the first board-row are given first
followed by the strings for the second row.
The strings for the last row on the board come last.
Within each row the strings are listed from left to right.
The first string in the file gives the letter(s)
on the die at the upper left corner of the board.
The last string in the file gives the letter(s)
on the die at the bottom right corner of the board.
The strings for a row on the board may be
listed on more than one line in the file.
</p>

<p>
Each string may be upper or lower case
and may contain one or more letters.
In official Boggle, each tile contains only one letter,
(except for one tile that contains 'Qu').
Your Boggle player needs to work correctly
with strings of any length.
</p>



<h3>
Output Format
</h3>

<p>
The output is a list of the words found
on the Boggle board, one word per line.
Each word given in the output must be:
</p>

<ol>

<li>
found in the dictionary

</li><li>
at least the minimum length of 4 letters

</li><li>
found on the board following the standard Boggle rules.
(Each tile can participate at most once in a given word.)

</li></ol>

<p>
The words are output in sorted order.
</p>

<p>
The words are output in lower case.
</p>

<p>
Each word is only output once even though
the board may contain the same word
in multiple locations.
</p>

<p>
The output is written to a file, not to the standard output.
</p>



<h3>
Testing
</h3>

<p>
You may use these files to do some minimal testing:
</p>

<a href="https://beta.cs.byu.edu/%7Ecs235/labs/lab3/in30a.txt">in30a.txt</a><br>
<a href="https://beta.cs.byu.edu/%7Ecs235/labs/lab3/in30b.txt">in30b.txt</a><br>
<a href="https://beta.cs.byu.edu/%7Ecs235/labs/lab3/out30.txt">out30.txt</a><br>
<br>

<p>
The files are also available in a zip archive:
</p>

<a href="https://beta.cs.byu.edu/%7Ecs235/labs/lab3/test30.zip">test30.zip</a><br>
<br>

<p>
You are required to write additional tests
to fully exercise all of your code.
Here are some ideas for additional tests.
</p>

<ol>
<li>
An empty dictionary file.
</li><li>
Boards of various sizes such as 9, 16, and 25.
</li><li>
Check that words cannot be made that are too short.
</li><li>
Check that words can be made with multi-letter tiles.
</li><li>
Check that words cannot be made by reusing tiles.
</li><li>
Check that words can be found in all directions.
</li><li>
Check that words cannot be made by skipping tiles.
</li><li>
Check that words cannot be made by wrapping around
at the edge of the board.
</li></ol>



<h3>
Design
</h3>

<p>
What classes will you use to solve this problem?
</p>

<p>
What data values will be stored in each class?
</p>

<p>
What operations will be supported on each class?
</p>

<p>
What algorithms will you use?
</p>



<h3>
Dictionary Operations
</h3>

<p>
If Boggle is to run in a reasonable amount of time,
the operations for searching the dictionary
must be fast, even for large dictionaries.
</p>

<p>
One way to make the search fast is to store the
dictionary in a Set and use the Set find operation
to search for a word.
The find operation for a Set in a data structure
library will typically be a very fast operation.
</p>

<p>
Another way to make the search fast is to store
the dictionary in a sorted List and use a
binary search algorithm to search for a word.
You would need to use a type of List that supports
efficient indexing (such as a vector).
</p>

<p>
When searching the Boggle board for words you will
need to stop following a path whenever you can
determine that the first part of the path does
not match a prefix of any word in the dictionary.
Thus you need to be able to search the dictionary
for prefixes and the prefix search must be fast.
</p>

<p>
If the dictionary is stored in a Set, many data
structure libraries provide a way to find the
string in the Set that is closest to the one
you are searching for.
Such an operation could be used to quickly find
a word with a given prefix.
</p>

<p>
If the dictionary is stored in a sorted List,
the binary search algorithm can be modified
to find the string in the List that is closest
to the one you are searching for.
</p>



<h3>
Word Search Operations
</h3>

<p>
You are required to find the words on the board
using a recursive search over the paths on the board.
Of course, there are many paths to be followed.
If Boggle is to run in a reasonable amount of time,
your algorithm will need to be intelligent about
avoiding wasted effort.
One way to speed up the search is to only follow paths
that have the possibility of leading to valid words.
Before moving along a path, the search algorithm should
ask the dictionary if any words begin with the
prefix represented by the current path.
If the answer is no, there is no need to follow the path further.
Checking prefixes in this manner will allow your algorithm
to avoid many dead-end paths, and therefore run more quickly.
In fact, if you don't do this, your program will
run too slowly to pass off.
</p>



<h3>
Implementation Requirements
</h3>

<ol>

<li>
Store the dictionary in a Set or a sorted List.

</li><li>
Use either a set operation or binary search
to locate a word in the dictionary that is closest
to a given prefix.

</li><li>
Use a recursive search over the contents of
the board to find the words.

</li><li>
Use a compare that is not case-sensitive
when comparing words on the board
with words in the dictionary.

</li><li>
Output the words in sorted order.

</li><li>
Output the words in lower case.

</li><li>
Avoid following dead-end paths,
thus allowing Boggle to run quickly on large boards.

</li></ol>



<h3>
Command Line
</h3>

<p>
The program is run with the names of the
dictionary, board, and output
files given on the command-line.
For example the program might be run like this:
</p>

<pre>lab3 dictionary.txt board.txt words.txt
</pre>



<h3>
Submission
</h3>

<p>
Submit all .h and .cpp files needed to build the project.
The project should build successfully with a simple command.
</p>

<pre>g++ *.cpp
</pre>

<p>
All files must have either a .h or .cpp extension.
Any files with a .h extension must be 'included'
in a file with a .cpp extension.
Do not use any subfolder structure.
All files must be in a single folder.
</p>


</div>





</body></html>